### 배운 점

문제를 해결하는 과정에서
for (int i = M; i <= N; i++) {
    for (int j = 2; j <= i / 2; j++) {
        if (i % j == 0) { ... }
    }
} 
코드의 해당 부분에서 시간복잡도가 최악의 경우 O((N-M)*N)에 가까워
메모리 및 시간에서 많이 소모

#### 에라토네스의 체를 사용해 해결할 수 있다.
-> 소수를 빠르게 찾는 알고리즘으로 배수를 지워 소수가 아닌 수를 걸러내는 방식

1. 2부터 N까지 수를 쭉 나열

2. 2의 배수를 지움(2는 소수 확정)

3. 다음 수인 3(2의 배수가 아니기 때문에 지워지지 않음)의 배수를 지움(3 소수 확정)

4. 4는 2의 배수에서 지워짐

5. 루트 N까지 반복(루트 N을 지나면 역순으로 반복되는 것이므로 루트 N까지 진행)
